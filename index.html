<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Agentic Chat</title>
  <style>
    body { font-family: system-ui, sans-serif; background:#111; color:#eee; margin:0; }
    h2 { text-align:center; padding:1rem 0; }
    .toolbar { max-width:700px; margin:0 auto 1rem; display:flex; gap:.5rem; }
    #api-key, #chat-input {
      flex:1; padding:.5rem; border-radius:5px; border:1px solid #444;
      background:#1a1a1a; color:#eee;
    }
    button {
      padding:.5rem 1rem; border:none; border-radius:5px;
      background:#38bdf8; color:#000; cursor:pointer;
    }
    button:hover { background:#0ea5e9; }
    #blackbox {
      max-width:700px; margin:0 auto 2rem; background:#0d0d0d;
      border:2px solid #333; border-radius:8px;
      padding:1rem; box-shadow:0 0 10px #000;
    }
    #chat-output { margin-bottom:1rem; white-space:pre-wrap; }
    #console-output {
      background:#222; padding:.75rem; border-radius:6px;
      font-family:monospace; min-height:2.5rem;
    }
    pre {
      background:#1a1a1a; padding:.75rem; border-radius:6px; overflow:auto;
    }
    #apikey-modal {
      position:fixed; inset:0; background:#0008;
      display:none; align-items:center; justify-content:center;
    }
    #apikey-modal-content {
      background:#fff; color:#000; padding:2rem; border-radius:8px;
      width:90%; max-width:400px; text-align:center;
    }
    #user-api-key {
      width:100%; padding:.5rem; margin-top:.5rem;
    }
    #last-prompt {
      max-width:700px; margin:0 auto 1rem; padding:.5rem;
      color:#aaa; font-style:italic; text-align:center;
    }
  </style>
</head>
<body>
  <h2>Agentic Chat</h2>

  <div class="toolbar">
    <input id="api-key" type="password" placeholder="OpenAI API Key">
  </div>

  <div class="toolbar">
    <input id="chat-input" placeholder="Ask anything…">
    <button onclick="sendChat()">Send</button>
    <button onclick="clearHistory()" style="background:#555;color:#eee;" title="Clear conversation history">Clear</button>
  </div>

  <div id="last-prompt">(no input yet)</div>

  <div id="blackbox">
    <div id="chat-output"></div>
    <div id="console-output">(results appear here)</div>
  </div>

  <!-- API Key Modal -->
  <div id="apikey-modal">
    <div id="apikey-modal-content">
      <p>API key needed for<br><strong id="api-service-name"></strong></p>
      <input id="user-api-key" type="password" placeholder="Paste key">
      <br><br><button onclick="submitUserApiKey()">OK</button>
    </div>
  </div>

  <script>
    const systemPrompt = `
You are an autonomous agent in a browser.
Only reply with JavaScript in a single code block.
If an external service needs a key use the placeholder "YOUR_API_KEY".
Always \`return\` the final value.
    `;

    const serviceKeys = {};
    let pendingCode = null, pendingDomain = null;

    // Store API key in a JS variable only — never persist in DOM (fixes #6)
    let _openaiKey = null;

    // Maximum number of user+assistant message pairs to keep (excluding system prompt).
    // 20 pairs ≈ 40 messages — keeps context well under GPT-4o's 128K limit
    // while preserving enough conversational context. (fixes #3)
    const MAX_HISTORY_PAIRS = 20;

    // Rough token estimate: ~4 characters per token (conservative)
    const CHARS_PER_TOKEN = 4;
    const TOKEN_WARNING_THRESHOLD = 80000; // warn at ~80K tokens

    // Conversation history — maintains context across messages (fixes #2)
    const history = [{ role: 'system', content: systemPrompt }];

    /**
     * Trim conversation history to keep at most MAX_HISTORY_PAIRS
     * user+assistant exchanges, always preserving the system prompt.
     */
    function trimHistory() {
      // Count non-system messages
      const messages = history.slice(1); // everything after system prompt
      const maxMessages = MAX_HISTORY_PAIRS * 2; // each pair = user + assistant

      if (messages.length > maxMessages) {
        const trimmed = messages.slice(messages.length - maxMessages);
        history.length = 0;
        history.push({ role: 'system', content: systemPrompt }, ...trimmed);
      }
    }

    /**
     * Estimate total token count of the current history.
     */
    function estimateTokens() {
      const totalChars = history.reduce((sum, m) => sum + m.content.length, 0);
      return Math.ceil(totalChars / CHARS_PER_TOKEN);
    }

    function clearHistory() {
      history.length = 0;
      history.push({ role: 'system', content: systemPrompt });
      document.getElementById('chat-output').textContent = '';
      document.getElementById('console-output').textContent = '(results appear here)';
      document.getElementById('last-prompt').textContent = '(history cleared)';
    }

    function extractDomain(code) {
      const m = code.match(/https?:\/\/([^/'"]+)/);
      return m ? m[1] : "Unknown Service";
    }

    /**
     * Execute LLM-generated code inside a sandboxed iframe so it cannot
     * access the parent page's DOM, API keys, cookies, or localStorage.
     * The iframe communicates results back via postMessage.
     */
    function runCode(code) {
      const out = document.getElementById('console-output');
      out.textContent = '(running in sandbox…)';

      // Generate a unique nonce to tie this execution to its result,
      // preventing stale or replayed postMessage events. (fixes #4, #5)
      const nonce = crypto.randomUUID();

      // Build a self-contained HTML document that runs the code and posts the result back.
      // The CSP allows outbound HTTPS requests (connect-src) so LLM-generated code can
      // call external APIs — the core use case of the app. Other dangerous capabilities
      // (DOM access, navigation, iframes, forms) remain blocked. The sandbox attribute
      // on the iframe already prevents same-origin access. (updated from #7)
      const iframeHTML = `<!DOCTYPE html><html><head><meta http-equiv="Content-Security-Policy" content="default-src 'none'; script-src 'unsafe-inline'; connect-src https:;"></head><body><script>
        (async () => {
          try {
            const __result = await (async () => { ${code} })();
            parent.postMessage({ type: 'sandbox-result', nonce: '${nonce}', ok: true, value: String(__result) }, '*');
          } catch (e) {
            parent.postMessage({ type: 'sandbox-result', nonce: '${nonce}', ok: false, value: 'Error: ' + e.message }, '*');
          }
        })();
      <\/script></body></html>`;

      // Remove any previous sandbox iframe
      const prev = document.getElementById('sandbox-frame');
      if (prev) prev.remove();

      const iframe = document.createElement('iframe');
      iframe.id = 'sandbox-frame';
      // sandbox="allow-scripts" — NO allow-same-origin, so the iframe
      // cannot access the parent's DOM, cookies, localStorage, or JS variables
      iframe.sandbox = 'allow-scripts';
      iframe.style.display = 'none';
      document.body.appendChild(iframe);

      // Listen for the result
      const timeout = setTimeout(() => {
        out.textContent = '(sandbox timed out after 30s)';
        cleanup();
      }, 30000);

      function cleanup() {
        clearTimeout(timeout);
        window.removeEventListener('message', onMessage);
        const f = document.getElementById('sandbox-frame');
        if (f) f.remove();
      }

      function onMessage(e) {
        // Validate origin: sandboxed iframes without allow-same-origin
        // send messages with origin 'null'. Reject all other origins
        // to prevent cross-origin result injection. (fixes #4, #5)
        if (e.origin !== 'null') return;

        // Validate nonce to ensure this result belongs to the current
        // runCode() invocation, not a stale or replayed message.
        if (e.data && e.data.type === 'sandbox-result' && e.data.nonce === nonce) {
          out.textContent = e.data.ok ? e.data.value : e.data.value;
          cleanup();
        }
      }

      window.addEventListener('message', onMessage);
      iframe.srcdoc = iframeHTML;
    }

    function askKey(domain, code) {
      pendingCode = code;
      pendingDomain = domain;
      document.getElementById('api-service-name').textContent = domain;
      document.getElementById('apikey-modal').style.display = 'flex';
      document.getElementById('user-api-key').focus();
    }

    function submitUserApiKey() {
      const k = document.getElementById('user-api-key').value.trim();
      if (!k) return;
      serviceKeys[pendingDomain] = k;
      document.getElementById('apikey-modal').style.display = 'none';
      runCode(pendingCode.replace(/YOUR_API_KEY/g, k));
      pendingCode = pendingDomain = null;
      document.getElementById('user-api-key').value = '';
    }

    function updateLastPrompt(prompt) {
      document.getElementById('last-prompt').textContent = `Last input: ${prompt}`;
    }

    let isSending = false;

    async function sendChat() {
      if (isSending) return;

      const prompt = document.getElementById('chat-input').value.trim();

      // On first send, read the key from the input, store in JS variable,
      // then clear and remove the input from the DOM entirely (fixes #6)
      if (!_openaiKey) {
        const openai = document.getElementById('api-key');
        const keyVal = openai ? openai.value.trim() : '';
        if (!keyVal || !prompt) {
          alert('Enter both your OpenAI key and a question.');
          return;
        }
        _openaiKey = keyVal;
        openai.value = '';            // clear the DOM value
        openai.remove();              // remove element entirely
      } else if (!prompt) {
        alert('Enter a question.');
        return;
      }

      const key = _openaiKey;

      const sendBtn = document.querySelector('.toolbar button');
      isSending = true;
      sendBtn.disabled = true;
      sendBtn.textContent = 'Sending…';

      updateLastPrompt(prompt);

      const chatOut = document.getElementById('chat-output');
      chatOut.textContent = 'Thinking…';
      document.getElementById('console-output').textContent = '(processing)';

      try {
        // Append user message to conversation history
        history.push({ role: 'user', content: prompt });

        const rsp = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${key}`
          },
          body: JSON.stringify({
            model: 'gpt-4o',
            messages: history
          })
        });

        if (!rsp.ok) {
          // Remove the user message we just added since the request failed
          history.pop();
          let errMsg = `OpenAI error ${rsp.status}`;
          try {
            const errBody = await rsp.json();
            const detail = errBody?.error?.message;
            if (detail) errMsg += `: ${detail}`;
          } catch (_) { /* response wasn't JSON, use status code only */ }

          // Provide actionable hints for common error codes
          if (rsp.status === 401) errMsg += ' — check your API key';
          else if (rsp.status === 429) errMsg += ' — rate limited, try again shortly';
          else if (rsp.status === 503) errMsg += ' — service temporarily unavailable';

          chatOut.textContent = errMsg;
          document.getElementById('console-output').textContent = '(request failed)';
          return;
        }

        const data = await rsp.json();
        const reply = data.choices?.[0]?.message?.content || 'No response';

        // Append assistant reply to conversation history
        history.push({ role: 'assistant', content: reply });

        // Trim history to sliding window to prevent unbounded growth (fixes #3)
        trimHistory();

        // Warn if estimated token count is getting high
        const estTokens = estimateTokens();
        if (estTokens > TOKEN_WARNING_THRESHOLD) {
          console.warn(`[agenticchat] History ~${estTokens} tokens — consider clicking Clear`);
        }

        const codeMatch = reply.match(/```(?:js|javascript)?\n([\s\S]*?)```/i);

        if (codeMatch) {
          const code = codeMatch[1];
          const pre = document.createElement('pre');
          pre.textContent = code;
          chatOut.innerHTML = '';
          chatOut.appendChild(pre);
          if (/YOUR_API_KEY/.test(code)) {
            const domain = extractDomain(code);
            if (serviceKeys[domain]) runCode(code.replace(/YOUR_API_KEY/g, serviceKeys[domain]));
            else askKey(domain, code);
          } else {
            runCode(code);
          }
        } else {
          chatOut.textContent = reply;
          document.getElementById('console-output').textContent = '(no code to run)';
        }
      } catch (err) {
        // Remove the user message we just added since the request failed
        if (history.length > 1 && history[history.length - 1].role === 'user') {
          history.pop();
        }
        chatOut.textContent = 'Network error: ' + err.message;
        document.getElementById('console-output').textContent = '(request failed)';
      } finally {
        isSending = false;
        sendBtn.disabled = false;
        sendBtn.textContent = 'Send';
        document.getElementById('chat-input').value = '';
      }
    }

    // Pressing Enter submits the chat
    document.getElementById('chat-input').addEventListener('keydown', function (e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        sendChat();
      }
    });

    // Pressing Enter in API key modal submits the key
    document.getElementById('user-api-key').addEventListener('keydown', function (e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        submitUserApiKey();
      }
    });
  </script>
</body>
</html>
