<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A lightweight browser-based chat interface that turns natural language prompts into executable JavaScript, powered by OpenAI GPT-4o.">
  <title>Agentic Chat</title>
  <style>
    body { font-family: system-ui, sans-serif; background:#111; color:#eee; margin:0; }
    h2 { text-align:center; padding:1rem 0; }
    .toolbar { max-width:700px; margin:0 auto 1rem; display:flex; gap:.5rem; }
    #api-key, #chat-input {
      flex:1; padding:.5rem; border-radius:5px; border:1px solid #444;
      background:#1a1a1a; color:#eee;
    }
    button {
      padding:.5rem 1rem; border:none; border-radius:5px;
      background:#38bdf8; color:#000; cursor:pointer;
    }
    button:hover { background:#0ea5e9; }
    button:disabled { background:#555; color:#999; cursor:not-allowed; }
    #blackbox {
      max-width:700px; margin:0 auto 2rem; background:#0d0d0d;
      border:2px solid #333; border-radius:8px;
      padding:1rem; box-shadow:0 0 10px #000;
    }
    #chat-output { margin-bottom:1rem; white-space:pre-wrap; }
    #console-output {
      background:#222; padding:.75rem; border-radius:6px;
      font-family:monospace; min-height:2.5rem;
    }
    pre {
      background:#1a1a1a; padding:.75rem; border-radius:6px; overflow:auto;
    }
    #apikey-modal {
      position:fixed; inset:0; background:#0008;
      display:none; align-items:center; justify-content:center;
    }
    #apikey-modal-content {
      background:#fff; color:#000; padding:2rem; border-radius:8px;
      width:90%; max-width:400px; text-align:center;
    }
    #user-api-key {
      width:100%; padding:.5rem; margin-top:.5rem;
    }
    #last-prompt {
      max-width:700px; margin:0 auto 1rem; padding:.5rem;
      color:#aaa; font-style:italic; text-align:center;
    }
    .sr-only {
      position:absolute; width:1px; height:1px; padding:0; margin:-1px;
      overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0;
    }
  </style>
</head>
<body>
  <h2>Agentic Chat</h2>

  <div class="toolbar" role="form" aria-label="API key entry">
    <label for="api-key" class="sr-only">OpenAI API Key</label>
    <input id="api-key" type="password" placeholder="OpenAI API Key" autocomplete="off">
  </div>

  <div class="toolbar" role="form" aria-label="Chat input">
    <label for="chat-input" class="sr-only">Your message</label>
    <input id="chat-input" placeholder="Ask anything…" autocomplete="off">
    <button id="send-btn" onclick="sendChat()">Send</button>
    <button id="cancel-btn" onclick="cancelExecution()" style="background:#ef4444;color:#fff;display:none;" title="Cancel running sandbox execution">Cancel</button>
    <button onclick="clearHistory()" style="background:#555;color:#eee;" title="Clear conversation history">Clear</button>
  </div>

  <div id="last-prompt">(no input yet)</div>

  <div id="blackbox">
    <div id="chat-output"></div>
    <div id="console-output" aria-live="polite">(results appear here)</div>
    <div id="token-usage" style="color:#888; font-size:0.8rem; margin-top:0.5rem; text-align:right;"></div>
  </div>

  <!-- API Key Modal -->
  <div id="apikey-modal" role="dialog" aria-modal="true" aria-labelledby="api-modal-title">
    <div id="apikey-modal-content">
      <p id="api-modal-title">API key needed for<br><strong id="api-service-name"></strong></p>
      <label for="user-api-key" class="sr-only">Service API key</label>
      <input id="user-api-key" type="password" placeholder="Paste key" autocomplete="off">
      <br><br><button onclick="submitUserApiKey()">OK</button>
    </div>
  </div>

  <script>
    const systemPrompt = `
You are an autonomous agent in a browser.
Only reply with JavaScript in a single code block.
If an external service needs a key use the placeholder "YOUR_API_KEY".
Always \`return\` the final value.
    `;

    const serviceKeys = {};
    let pendingCode = null, pendingDomain = null;

    // Store API key in a JS variable only — never persist in DOM (fixes #6)
    let _openaiKey = null;

    // Maximum number of user+assistant message pairs to keep (excluding system prompt).
    // 20 pairs ≈ 40 messages — keeps context well under GPT-4o's 128K limit
    // while preserving enough conversational context. (fixes #3)
    const MAX_HISTORY_PAIRS = 20;

    // Rough token estimate: ~4 characters per token (conservative)
    const CHARS_PER_TOKEN = 4;
    const TOKEN_WARNING_THRESHOLD = 80000; // warn at ~80K tokens

    // Conversation history — maintains context across messages (fixes #2)
    const history = [{ role: 'system', content: systemPrompt }];

    /**
     * Trim conversation history to keep at most MAX_HISTORY_PAIRS
     * user+assistant exchanges, always preserving the system prompt.
     */
    function trimHistory() {
      // Count non-system messages
      const messages = history.slice(1); // everything after system prompt
      const maxMessages = MAX_HISTORY_PAIRS * 2; // each pair = user + assistant

      if (messages.length > maxMessages) {
        const trimmed = messages.slice(messages.length - maxMessages);
        history.length = 0;
        history.push({ role: 'system', content: systemPrompt }, ...trimmed);
      }
    }

    /**
     * Estimate total token count of the current history.
     */
    function estimateTokens() {
      const totalChars = history.reduce((sum, m) => sum + m.content.length, 0);
      return Math.ceil(totalChars / CHARS_PER_TOKEN);
    }

    function clearHistory() {
      history.length = 0;
      history.push({ role: 'system', content: systemPrompt });
      document.getElementById('chat-output').textContent = '';
      document.getElementById('console-output').textContent = '(results appear here)';
      document.getElementById('last-prompt').textContent = '(history cleared)';
    }

    function extractDomain(code) {
      const m = code.match(/https?:\/\/([^/'"]+)/);
      return m ? m[1] : "Unknown Service";
    }

    // Track the current sandbox cleanup function so it can be called
    // from the Cancel button. Null when no sandbox is running. (fixes #13)
    let _sandboxCleanup = null;

    /**
     * Cancel the currently running sandbox execution, if any.
     * Destroys the iframe immediately and resets UI state. (fixes #13)
     */
    function cancelExecution() {
      if (_sandboxCleanup) {
        _sandboxCleanup();
        document.getElementById('console-output').textContent = '(execution cancelled)';
      }
    }

    /**
     * Show/hide the Cancel button and keep Send disabled while the
     * sandbox is running so the user has a clear execution indicator. (fixes #13)
     */
    function setSandboxRunning(running) {
      const cancelBtn = document.getElementById('cancel-btn');
      const sendBtn = document.getElementById('send-btn');
      cancelBtn.style.display = running ? 'inline-block' : 'none';
      if (running) {
        sendBtn.disabled = true;
        sendBtn.textContent = 'Running…';
      }
    }

    /**
     * Execute LLM-generated code inside a sandboxed iframe so it cannot
     * access the parent page's DOM, API keys, cookies, or localStorage.
     * The iframe communicates results back via postMessage.
     *
     * Code is delivered to the iframe via postMessage (not template-literal
     * interpolation) to prevent script-tag injection — if the LLM generates
     * code containing `<\/script>`, embedding it directly in srcdoc would
     * break out of the script context. (fixes #10)
     */
    function runCode(code) {
      const out = document.getElementById('console-output');
      out.textContent = '(running in sandbox…)';

      // Show Cancel button and keep Send disabled during execution (fixes #13)
      setSandboxRunning(true);

      // Generate a unique nonce to tie this execution to its result,
      // preventing stale or replayed postMessage events. (fixes #4, #5)
      const nonce = crypto.randomUUID();

      // The iframe now waits for a 'sandbox-exec' postMessage containing the
      // code and nonce, instead of having them embedded in the HTML. This
      // eliminates the injection vector entirely. (fixes #10)
      const iframeHTML = `<!DOCTYPE html><html><head><meta http-equiv="Content-Security-Policy" content="default-src 'none'; script-src 'unsafe-inline'; connect-src https:;"></head><body><script>
        window.addEventListener('message', async function handler(evt) {
          if (!evt.data || evt.data.type !== 'sandbox-exec') return;
          window.removeEventListener('message', handler);
          var code = evt.data.code;
          var nonce = evt.data.nonce;
          try {
            var fn = new Function('return (async () => {' + code + '})()');
            var __result = await fn();
            parent.postMessage({ type: 'sandbox-result', nonce: nonce, ok: true, value: String(__result) }, '*');
          } catch (e) {
            parent.postMessage({ type: 'sandbox-result', nonce: nonce, ok: false, value: 'Error: ' + e.message }, '*');
          }
        });
        parent.postMessage({ type: 'sandbox-ready' }, '*');
      <\/script></body></html>`;

      // Remove any previous sandbox iframe
      const prev = document.getElementById('sandbox-frame');
      if (prev) prev.remove();

      const iframe = document.createElement('iframe');
      iframe.id = 'sandbox-frame';
      // sandbox="allow-scripts" — NO allow-same-origin, so the iframe
      // cannot access the parent's DOM, cookies, localStorage, or JS variables
      iframe.sandbox = 'allow-scripts';
      iframe.style.display = 'none';
      document.body.appendChild(iframe);

      // Listen for the result
      const timeout = setTimeout(() => {
        out.textContent = '(sandbox timed out after 30s)';
        cleanup();
      }, 30000);

      function cleanup() {
        clearTimeout(timeout);
        window.removeEventListener('message', onMessage);
        const f = document.getElementById('sandbox-frame');
        if (f) f.remove();
        // Reset sandbox state — hide Cancel, re-enable Send (fixes #13)
        _sandboxCleanup = null;
        setSandboxRunning(false);
        // Re-enable Send button fully (sendChat's finally block handles
        // the isSending flag, but if code was run from askKey path we
        // need to ensure the button is usable)
        const sendBtn = document.getElementById('send-btn');
        if (!isSending) {
          sendBtn.disabled = false;
          sendBtn.textContent = 'Send';
        }
      }

      // Expose cleanup for the Cancel button (fixes #13)
      _sandboxCleanup = cleanup;

      function onMessage(e) {
        // Validate origin: sandboxed iframes without allow-same-origin
        // send messages with origin 'null'. Reject all other origins
        // to prevent cross-origin result injection. (fixes #4, #5)
        if (e.origin !== 'null') return;

        if (e.data && e.data.type === 'sandbox-ready') {
          // Iframe is ready — send the code via postMessage instead of
          // embedding it in srcdoc. This is safe because postMessage
          // data is never parsed as HTML/script. (fixes #10)
          iframe.contentWindow.postMessage({
            type: 'sandbox-exec',
            code: code,
            nonce: nonce
          }, '*');
          return;
        }

        // Validate nonce to ensure this result belongs to the current
        // runCode() invocation, not a stale or replayed message.
        if (e.data && e.data.type === 'sandbox-result' && e.data.nonce === nonce) {
          out.textContent = e.data.value;
          out.style.color = e.data.ok ? '#4ade80' : '#f87171';
          cleanup();
        }
      }

      window.addEventListener('message', onMessage);
      iframe.srcdoc = iframeHTML;
    }

    function askKey(domain, code) {
      pendingCode = code;
      pendingDomain = domain;
      document.getElementById('api-service-name').textContent = domain;
      document.getElementById('apikey-modal').style.display = 'flex';
      document.getElementById('user-api-key').focus();
    }

    function submitUserApiKey() {
      const k = document.getElementById('user-api-key').value.trim();
      if (!k) return;
      serviceKeys[pendingDomain] = k;
      document.getElementById('apikey-modal').style.display = 'none';
      runCode(pendingCode.replace(/YOUR_API_KEY/g, k));
      pendingCode = pendingDomain = null;
      document.getElementById('user-api-key').value = '';
    }

    function updateLastPrompt(prompt) {
      document.getElementById('last-prompt').textContent = `Last input: ${prompt}`;
    }

    let isSending = false;

    async function sendChat() {
      if (isSending) return;

      const prompt = document.getElementById('chat-input').value.trim();

      // On first send, read the key from the input, store in JS variable,
      // then clear and remove the input from the DOM entirely (fixes #6)
      if (!_openaiKey) {
        const openai = document.getElementById('api-key');
        const keyVal = openai ? openai.value.trim() : '';
        if (!keyVal || !prompt) {
          alert('Enter both your OpenAI key and a question.');
          return;
        }
        _openaiKey = keyVal;
        openai.value = '';            // clear the DOM value
        openai.remove();              // remove element entirely
      } else if (!prompt) {
        alert('Enter a question.');
        return;
      }

      const key = _openaiKey;

      const sendBtn = document.getElementById('send-btn');
      const chatInput = document.getElementById('chat-input');
      isSending = true;
      sendBtn.disabled = true;
      sendBtn.textContent = 'Sending…';
      chatInput.disabled = true;

      updateLastPrompt(prompt);

      const chatOut = document.getElementById('chat-output');
      chatOut.textContent = 'Thinking…';
      document.getElementById('console-output').textContent = '(processing)';

      try {
        // Append user message to conversation history
        history.push({ role: 'user', content: prompt });

        const rsp = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${key}`
          },
          body: JSON.stringify({
            model: 'gpt-4o',
            messages: history,
            max_tokens: 4096
          })
        });

        if (!rsp.ok) {
          // Remove the user message we just added since the request failed
          history.pop();
          let errMsg = `OpenAI error ${rsp.status}`;
          try {
            const errBody = await rsp.json();
            const detail = errBody?.error?.message;
            if (detail) errMsg += `: ${detail}`;
          } catch (_) { /* response wasn't JSON, use status code only */ }

          // Provide actionable hints for common error codes
          if (rsp.status === 401) {
            errMsg += ' — check your API key';
            // Reset stored key and re-show the input so user can retry (fixes #12)
            _openaiKey = null;
            if (!document.getElementById('api-key')) {
              const toolbar = document.querySelector('.toolbar[aria-label="API key entry"]');
              if (toolbar) {
                const inp = document.createElement('input');
                inp.id = 'api-key';
                inp.type = 'password';
                inp.placeholder = 'OpenAI API Key';
                inp.autocomplete = 'off';
                toolbar.appendChild(inp);
                inp.focus();
              }
            }
          }
          else if (rsp.status === 429) errMsg += ' — rate limited, try again shortly';
          else if (rsp.status === 503) errMsg += ' — service temporarily unavailable';

          chatOut.textContent = errMsg;
          document.getElementById('console-output').textContent = '(request failed)';
          return;
        }

        const data = await rsp.json();
        const reply = data.choices?.[0]?.message?.content || 'No response';

        // Append assistant reply to conversation history
        history.push({ role: 'assistant', content: reply });

        // Trim history to sliding window to prevent unbounded growth (fixes #3)
        trimHistory();

        // Display token usage from the API response (fixes #9)
        const usage = data.usage;
        if (usage) {
          const promptTokens = usage.prompt_tokens || 0;
          const completionTokens = usage.completion_tokens || 0;
          const totalTokens = usage.total_tokens || (promptTokens + completionTokens);
          // GPT-4o pricing: ~$2.50/1M input, ~$10/1M output
          const estCost = (promptTokens * 2.5 + completionTokens * 10) / 1_000_000;
          document.getElementById('token-usage').textContent =
            `Tokens: ${promptTokens} in / ${completionTokens} out (${totalTokens} total) · ~$${estCost.toFixed(4)}`;
        }

        // Warn if estimated token count is getting high
        const estTokens = estimateTokens();
        if (estTokens > TOKEN_WARNING_THRESHOLD) {
          console.warn(`[agenticchat] History ~${estTokens} tokens — consider clicking Clear`);
        }

        const codeMatch = reply.match(/```(?:js|javascript)?\n([\s\S]*?)```/i);

        if (codeMatch) {
          const code = codeMatch[1];
          const pre = document.createElement('pre');
          pre.textContent = code;
          chatOut.innerHTML = '';
          chatOut.appendChild(pre);
          if (/YOUR_API_KEY/.test(code)) {
            const domain = extractDomain(code);
            if (serviceKeys[domain]) runCode(code.replace(/YOUR_API_KEY/g, serviceKeys[domain]));
            else askKey(domain, code);
          } else {
            runCode(code);
          }
        } else {
          chatOut.textContent = reply;
          document.getElementById('console-output').textContent = '(no code to run)';
        }
      } catch (err) {
        // Remove the user message we just added since the request failed
        if (history.length > 1 && history[history.length - 1].role === 'user') {
          history.pop();
        }
        chatOut.textContent = 'Network error: ' + err.message;
        document.getElementById('console-output').textContent = '(request failed)';
      } finally {
        isSending = false;
        sendBtn.disabled = false;
        sendBtn.textContent = 'Send';
        chatInput.disabled = false;
        chatInput.value = '';
        chatInput.focus();
      }
    }

    // Pressing Enter submits the chat
    document.getElementById('chat-input').addEventListener('keydown', function (e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        sendChat();
      }
    });

    // Pressing Enter in API key modal submits the key
    document.getElementById('user-api-key').addEventListener('keydown', function (e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        submitUserApiKey();
      }
    });
  </script>
</body>
</html>
